#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Standalone script to build the consolidated Phase 4 PDF report.

This version mirrors the layout of :func:`export_report_to_pdf` from the
main pipeline but does not depend on the project modules. It gathers the
figures generated by ``phase4.py`` and assembles them into a structured
PDF using ``fpdf`` when available (falling back to ``PdfPages``).
"""

import argparse
import datetime
import io
import logging
import os
import tempfile
from contextlib import suppress
from pathlib import Path
from typing import Mapping, Union

import yaml
import pandas as pd
import matplotlib

matplotlib.use("Agg")
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
import numpy as np

logger = logging.getLogger(__name__)

# Datasets processed by phase4.py in typical order
DEFAULT_DATASETS = ["raw", "cleaned_1", "cleaned_3_multi", "cleaned_3_univ"]


def gather_figures(base_dir: Path, datasets: list[str]) -> dict[str, Path]:
    """Return a mapping of figure names to file paths under ``base_dir``."""

    methods = {
        "pca",
        "mca",
        "famd",
        "mfa",
        "umap",
        "pacmap",
        "phate",
        "tsne",
        "trimap",
    }

    valid_kw = {
        "scatter_2d",
        "correlation",
        "cluster",
        "scree",
        "contrib",
        "robustness",
        "silhouette",
        "dunn",
        "stability",
        "segments",
    }

    figures: dict[str, Path] = {}
    for ds in datasets:
        ds_dir = base_dir / ds
        if not ds_dir.exists():
            continue
        # Search only the expected <dataset>/<method> directories
        for method_dir in sorted(
            p for p in ds_dir.iterdir() if p.is_dir() and p.name.lower() in methods
        ):
            prefix = method_dir.name.lower()
            for img in sorted(method_dir.glob(f"{prefix}*.png")):
                name = img.name.lower()
                if any(k in name for k in valid_kw):
                    figures[f"{ds}_{img.stem}"] = img
        # Include any dataset-level PNGs (segment summaries, etc.)
        for img in sorted(ds_dir.glob("*.png")):
            figures[f"{ds}_{img.stem}"] = img

    # Top-level figures such as heatmaps
    for img in base_dir.glob("*.png"):
        figures[img.stem] = img

    return figures


def gather_metrics(base_dir: Path, datasets: list[str]) -> pd.DataFrame | None:
    """Concatenate the metrics.csv files of each dataset when available."""
    frames: list[pd.DataFrame] = []
    for ds in datasets:
        csv_path = base_dir / ds / "metrics.csv"
        if not csv_path.exists():
            continue
        try:
            df = pd.read_csv(csv_path, index_col=0)
        except Exception:
            df = pd.read_csv(csv_path)
        if "method" not in df.columns:
            df = df.rename(columns={df.columns[0]: "method"})
        df["dataset"] = ds
        frames.append(df)
    return pd.concat(frames, ignore_index=True) if frames else None


def _table_to_figure(df: pd.DataFrame, title: str) -> plt.Figure:
    """Render ``df`` as a Matplotlib table figure."""
    fig_height = 0.4 * len(df) + 1.5
    fig_height = min(fig_height, 8.27)
    fig, ax = plt.subplots(figsize=(11.69, fig_height), dpi=200)
    ax.axis("off")
    ax.set_title(title)
    table = ax.table(
        cellText=df.values,
        colLabels=list(df.columns),
        rowLabels=list(df.index),
        cellLoc="center",
        rowLoc="center",
        loc="center",
    )
    table.scale(1, 1.2)
    fig.tight_layout()
    return fig


def format_metrics_table(df: pd.DataFrame) -> pd.DataFrame:
    """Return ``df`` with values nicely formatted as strings."""
    formatted = df.copy()
    for col in formatted.columns:
        series = formatted[col]
        if col == "variance_cumulee_%":
            formatted[col] = series.map(lambda x: f"{int(round(x))}" if pd.notna(x) else "")
        elif col == "nb_axes_kaiser":
            formatted[col] = series.map(lambda x: f"{int(x)}" if pd.notna(x) else "")
        elif pd.api.types.is_integer_dtype(series):
            formatted[col] = series.map(lambda x: f"{int(x)}" if pd.notna(x) else "")
        elif pd.api.types.is_float_dtype(series):
            formatted[col] = series.map(lambda x: f"{x:.2f}" if pd.notna(x) else "")
        else:
            formatted[col] = series.astype(str).replace("nan", "")
    return formatted


def export_report_to_pdf(
    figures: Mapping[str, Union[plt.Figure, str, Path]],
    tables: Mapping[str, Union[pd.DataFrame, str, Path]],
    output_path: str | Path,
) -> Path | None:
    """Create a structured PDF gathering all figures.

    Tables are accepted for backward compatibility but ignored so that the
    generated report only contains graphics.
    """
    if not isinstance(output_path, (str, Path)):
        raise TypeError("output_path must be a path-like object")

    out = Path(output_path)
    out.parent.mkdir(parents=True, exist_ok=True)

    logger.info("Exporting PDF report to %s", out)

    plt.close("all")

    METHODS = {
        "pca",
        "mca",
        "famd",
        "mfa",
        "umap",
        "pacmap",
        "phate",
        "tsne",
        "trimap",
    }

    def _to_image(src: Path | plt.Figure | None) -> np.ndarray | None:
        if src is None:
            return None
        if isinstance(src, (str, Path)):
            return plt.imread(str(src))
        buf = io.BytesIO()
        src.savefig(buf, format="png", dpi=200)
        buf.seek(0)
        img = plt.imread(buf)
        buf.close()
        return img

    def _combine_scatter(
        fig2d: Path | plt.Figure | None, fig3d: Path | plt.Figure | None
    ) -> plt.Figure | None:
        img2d = _to_image(fig2d)
        img3d = _to_image(fig3d)
        if img2d is None and img3d is None:
            return None
        if img2d is not None and img3d is not None:
            fig, axes = plt.subplots(1, 2, figsize=(11, 8.5), dpi=200)
            axes[0].imshow(img2d)
            axes[0].axis("off")
            axes[1].imshow(img3d)
            axes[1].axis("off")
        else:
            fig, ax = plt.subplots(figsize=(11, 8.5), dpi=200)
            img = img2d if img2d is not None else img3d
            ax.imshow(img)
            ax.axis("off")
        fig.tight_layout()
        return fig

    def _fig_to_path(fig: plt.Figure | Path | str | None, tmp_list: list[str]) -> str | None:
        if fig is None:
            return None
        if isinstance(fig, (str, Path)):
            return str(fig)
        tmp = tempfile.NamedTemporaryFile(suffix=".png", delete=False)
        fig.savefig(tmp.name, dpi=200, bbox_inches="tight")
        plt.close(fig)
        tmp_list.append(tmp.name)
        return tmp.name

    grouped: dict[str, dict[str, dict[str, Union[plt.Figure, Path, str]]]] = {}
    used_keys: set[str] = set()

    for key, fig in figures.items():
        parts = key.split("_")
        dataset = "main"
        method = None
        idx = 0
        for i, part in enumerate(parts):
            if part.lower() in METHODS:
                method = part.lower()
                dataset = "_".join(parts[:i]) or "main"
                idx = i + 1
                break
        if method is None:
            continue
        fig_type = "_".join(parts[idx:])
        grouped.setdefault(dataset, {}).setdefault(method, {})[fig_type] = fig
        used_keys.add(key)

    remaining = {k: v for k, v in figures.items() if k not in used_keys}
    segment_figs = {
        k: v for k, v in remaining.items() if "segment_summary_2" in k
    }
    for k in segment_figs:
        del remaining[k]

    try:
        from fpdf import FPDF  # type: ignore

        pdf = FPDF(orientation="L", format="A4", unit="mm")
        pdf.set_auto_page_break(auto=True, margin=10)

        def _add_title(text: str, size: int = 14) -> None:
            pdf.set_font("Helvetica", "B", size)
            pdf.cell(0, 10, txt=text, ln=1, align="C")

        pdf.add_page()
        _add_title("Rapport d'analyse Phase 4 – Résultats Dimensionnels", 16)
        pdf.set_font("Helvetica", size=12)
        today = datetime.datetime.now().strftime("%Y-%m-%d")
        pdf.cell(0, 10, f"Généré le {today}", ln=1, align="C")


        # Tables are intentionally ignored to keep the report concise.

        tmp_paths: list[str] = []

        for dataset in sorted(grouped):
            for method in sorted(grouped[dataset]):
                items = grouped[dataset][method]
                pages = [
                    (
                        _combine_scatter(items.get("scatter_2d"), items.get("scatter_3d")),
                        "Nuages de points bruts",
                    )
                ]
                for algo in ["kmeans", "agglomerative", "gmm", "spectral"]:
                    key = f"{algo}_kgrid"
                    if key in items:
                        pages.append((items[key], f"Clusters {algo}"))
                pages += [
                    (items.get("cluster_grid"), "Nuages clusterisés"),
                    (items.get("analysis_summary"), "Analyse détaillée"),
                ]
                for fig, label in pages:
                    img = _fig_to_path(fig, tmp_paths)
                    if img:
                        pdf.add_page()
                        _add_title(f"{dataset} – {method.upper()} – {label}")
                        pdf.image(img, w=180)

        for name, fig in segment_figs.items():
            img = _fig_to_path(fig, tmp_paths)
            if img:
                pdf.add_page()
                ds = name.rsplit("_segment_summary_2", 1)[0]
                _add_title(f"% NA par segment – {ds}")
                pdf.image(img, w=180)

        for name, fig in remaining.items():
            img = _fig_to_path(fig, tmp_paths)
            if img:
                pdf.add_page()
                _add_title(name)
                pdf.image(img, w=180)

        pdf.output(str(out))

        for p in tmp_paths:
            with suppress(OSError):
                os.remove(p)

        plt.close("all")

    except Exception:  # pragma: no cover - fallback when FPDF not installed
        logger.info("FPDF not available, falling back to PdfPages")

        with PdfPages(out) as pdf_backend:
            fig, ax = plt.subplots(figsize=(11.69, 8.27), dpi=200)
            today = datetime.datetime.now().strftime("%Y-%m-%d")
            ax.text(0.5, 0.6, "Rapport des analyses – Phase 4", fontsize=20, ha="center", va="center")
            ax.text(0.5, 0.4, f"Généré le {today}", fontsize=12, ha="center", va="center")
            ax.axis("off")
            pdf_backend.savefig(fig, dpi=300)
            plt.close(fig)

            def _save_page(title: str, fig: plt.Figure | Path | str | None) -> None:
                if fig is None:
                    return
                if isinstance(fig, (str, Path)):
                    img = plt.imread(fig)
                    f, ax = plt.subplots()
                    ax.imshow(img)
                    ax.axis("off")
                    f.suptitle(title, fontsize=12)
                    pdf_backend.savefig(f, dpi=300)
                    plt.close(f)
                else:
                    fig.suptitle(title, fontsize=12)
                    pdf_backend.savefig(fig, dpi=300)
                    plt.close(fig)

            for dataset in sorted(grouped):
                for method in sorted(grouped[dataset]):
                    items = grouped[dataset][method]
                    pages = [
                        (
                            _combine_scatter(items.get("scatter_2d"), items.get("scatter_3d")),
                            "Nuages de points bruts",
                        )
                    ]
                    for algo in ["kmeans", "agglomerative", "gmm", "spectral"]:
                        key = f"{algo}_kgrid"
                        if key in items:
                            pages.append((items[key], f"Clusters {algo}"))
                    pages += [
                        (items.get("cluster_grid"), "Nuages clusterisés"),
                        (items.get("analysis_summary"), "Analyse détaillée"),
                    ]
                    for fig, label in pages:
                        _save_page(f"{dataset} – {method.upper()} – {label}", fig)

            for name, fig in segment_figs.items():
                ds = name.rsplit("_segment_summary_2", 1)[0]
                _save_page(f"% NA par segment – {ds}", fig)

            for name, fig in remaining.items():
                _save_page(name, fig)


            # Tables used to be converted to figures and appended here, but
            # they are skipped in the streamlined report.

        plt.close("all")

    return out


def main(argv: list[str] | None = None) -> None:
    parser = argparse.ArgumentParser(description="Assemble Phase 4 PDF report")
    parser.add_argument("--config", default="config.yaml", help="Config file")
    parser.add_argument(
        "--datasets", nargs="+", default=DEFAULT_DATASETS, help="Datasets processed by phase4.py"
    )
    args = parser.parse_args(argv)

    with open(args.config, "r", encoding="utf-8") as fh:
        cfg = yaml.safe_load(fh)

    output_dir = Path(cfg.get("output_dir", "phase4_output"))
    output_pdf = Path(cfg.get("output_pdf", output_dir / "phase4_report.pdf"))

    figures = gather_figures(output_dir, args.datasets)
    logging.info("Found %d images in %s", len(figures), output_dir)
    metrics = gather_metrics(output_dir, args.datasets)
    tables = {"metrics": format_metrics_table(metrics)} if metrics is not None else {}

    export_report_to_pdf(figures, tables, output_pdf)
    logging.info("Report written to %s", output_pdf)


if __name__ == "__main__":  # pragma: no cover - manual execution
    logging.basicConfig(level=logging.INFO)
    main()
